[{"content":"Java Java 8 流的新类 java.util.stream.Collectors 实现了 java.util.stream.Collector 接口，同时又提供了大量的方法对流 ( stream ) 的元素执行 map and reduce 操作，或者统计操作。\nCollectors.averagingDouble() Collectors.averagingDouble() 方法将流中的所有元素视为 double 类型并计算他们的平均值。该方法返回的是同一个 Collectors 实例，因此可以进行链式操作。\nCollectors.averagingDouble() 接受一个参数，这个参数是一个 lambda 表达式，用于对所有的元素执行一个 map 操作。\nJava 所有集合的 stream().collect() 可以接受一个收集器实例作为其参数并返回该收集器的计算结果\n例如下面的代码，collect() 方法会把所有的元素收集起来然后传递给 Collectors.averagingDouble(d-\u0026gt;d*2) 收集器，对每个元素执行 *2 操作后计算平均值。\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class AveragingDoubleExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(1,2,3,4); Double result = list.stream().collect(Collectors.averagingDouble(d-\u0026gt;d*2)); System.out.println(result); } } 输出结果为 5.0   Collectors.averagingInt() Collectors.averagingInt() 方法和 Collectors.averagingDouble() 一样，不同的是它把流中的所有元素看成是 int类型，并返回一个浮点类型的平均值\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class AveragingIntExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(1,2,3,4); Double result = list.stream().collect(Collectors.averagingInt(v-\u0026gt;v*2)); System.out.println(result); } } 输出结果为 5.0   Collectors.averagingLong() Collectors.averagingLong() 方法也和 Collectors.averagingDouble() 类似，不同的是它把流中的所有元素看成是 long类型，并返回一个 double类型的平均值\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech..util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class AveragingLongExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(1,2,3,4); Double result = list.stream().collect(Collectors.averagingLong(v-\u0026gt;v*2)); System.out.println(result); } } 输出结果为 5.0\t  Collectors.collectingAndThen() Collectors.collectingAndThen() 函数应该最像 map and reduce 了，它可接受两个参数，第一个参数用于 reduce操作，而第二参数用于 map操作。\n也就是，先把流中的所有元素传递给第二个参数，然后把生成的集合传递给第一个参数来处理。\n例如下面的代码，先把 [1,2,3,4] 这个集合传递给 s-\u0026gt; s*s lambda 表达式，计算得出结果为[1,4,9,16] ，然后再把 [1,4,9,16]传递给 v-\u0026gt;v*2 表达式，计算得出 [2,8,18,32] ，然后传递给 Collectors.averagingLong() 计算得到结果为 25.0\n1 2 3 4 5 6 7 8 9 10 11 12 13  package com.souyunku.tech..util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class CollectingAndThenExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(1,2,3,4); Double result = list.stream().collect(Collectors.collectingAndThen(Collectors.averagingLong(v-\u0026gt;v*2), s-\u0026gt; s*s)); System.out.println(result); } }   Collectors.counting() Collectors.counting() 用于统计流中元素的个数。\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class CountingExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(1,2,3,4); long result= list.stream().collect(Collectors.counting()); System.out.println(result); } } 输出结果为 4   Collectors.joining() Collectors.joining() 方法用某个指定的拼接字符串把所有元素拼接成一个字符串，并添加可选的前缀和后缀\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;); String result= list.stream().collect(Collectors.joining(\u0026#34;,\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;)); System.out.println(result); } } 输出结果为 (A,B,C,D)   Collectors.maxBy() 和 Collectors.minBy()\nCollectors.maxBy() 和Collectors.minBy() 两个方法分别用于计算流中所有元素的最大值和最小值。\n两个方法都可以接受一个比较器作为参数，用于如何计算最大值或最小值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors; public class MaxByMinByExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(30,10,20,35); //Get Max  list.stream().collect(Collectors.maxBy(new MaxByMinByExample().new IntegerComp())) .ifPresent(i-\u0026gt;System.out.println(i)); //Get Min  list.stream().collect(Collectors.minBy(new MaxByMinByExample().new IntegerComp())) .ifPresent(i-\u0026gt;System.out.println(i)); } class IntegerComp implements Comparator\u0026lt;Integer\u0026gt; { @Override public int compare(Integer i1, Integer i2) { if(i1 \u0026gt;=i2 ){ return 1; }else{ return -1; } } } } 输出结果如下 35 10   Collectors.summingInt() Collectors.summingInt() 方法将流中的所有元素视为 int类型，并计算所有元素的总和 ( sum )\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class SummingIntExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Arrays.asList(30,10,20,35); int result = list.stream().collect(Collectors.summingInt(i-\u0026gt;i)); System.out.println(result); } } 输出结果我为 95   Collectors.summingLong() Collectors.summingLong() 将流中的所有元素视为 long类型，并计算所有元素的总和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package com.souyunku.tech.util.stream; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors; public class SummingLongExample { public static void main(String[] args) { List\u0026lt;Long\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add((long)340); list.add((long)240); list.add((long)360); long result = list.stream().collect(Collectors.summingLong(l-\u0026gt;l)); System.out.println(result); } }   Collectors.summingDouble() Collectors.summingDouble() 将流中的所有元素视为 double类型，并计算所有元素的总和\n1 2 3 4 5 6 7 8 9 10 11 12  package cn.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class SummingDoubleExample { public static void main(String[] args) { List\u0026lt;Double\u0026gt; list = Arrays.asList(340.5,234.56,672.76); Double result = list.stream().collect(Collectors.summingDouble(d-\u0026gt;d)); System.out.println(result); } } 输出结果为 1247.82   也许你也注意到了，这三个函数的结果的类型，就是它们如何看待元素的类型。\nCollectors.toList() Collectors.toList() 将流中的所有元素导出到一个列表( List )中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package com.souyunku.tech.util.stream; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; public class ToListExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Stream.of(\u0026#34;AA\u0026#34;,\u0026#34;BB\u0026#34;,\u0026#34;CC\u0026#34;).collect(Collectors.toList()); list.forEach(s-\u0026gt;System.out.println(s)); } } 输出结果如下 AA BB CC   Collectors.toSet() Collectors.toSet()把流中的所有元素导出到一个集合 ( Set )中，并排除重复的元素 ( Set 的特性 )\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package com.souyunku.tech.util.stream; import java.util.Set; import java.util.stream.Collectors; import java.util.stream.Stream; public class ToSetExample { public static void main(String[] args) { Set\u0026lt;String\u0026gt; set = Stream.of(\u0026#34;AA\u0026#34;,\u0026#34;AA\u0026#34;,\u0026#34;BB\u0026#34;).collect(Collectors.toSet()); set.forEach(s-\u0026gt;System.out.println(s)); } } 输出结果为 AA BB   Collectors.toMap() Collectors.toMap() 将流中的所有元素导出到一个哈希表 ( Map ) 中。该方法接受两个参数，第一个参数用于生成键 ( key ) ，第二个参数用于生成值 ( value )。两个参数都是 Lambda 表达式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package com.souyunku.tech.util.stream; import java.util.Map; import java.util.stream.Collectors; import java.util.stream.Stream; public class ToMapExample { public static void main(String[] args) { Map\u0026lt;String,String\u0026gt; map = Stream.of(\u0026#34;AA\u0026#34;,\u0026#34;BB\u0026#34;,\u0026#34;CC\u0026#34;).collect(Collectors.toMap(k-\u0026gt;k, v-\u0026gt;v+v)); map.forEach((k,v)-\u0026gt;System.out.println(\u0026#34;key:\u0026#34;+k +\u0026#34; value:\u0026#34;+v)); } 输出结果为 key:CC value:CCCC key:BB value:BBBB key:AA value:AAAA   Collectors.mapping() Collectors.mapping() 一般用于多重 map and reduce 中。 Java 文档中描述的原型如下\nmapping(Function\u0026lt;? super T,? extends U\u0026gt; mapper, Collector\u0026lt;? super U,A,R\u0026gt; downstream)\n第一个参数用于 map ，第二个参数用于 reduce\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package com.souyunku.tech.util.stream; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.stream.Collectors; public class MappingDemo { public static void main(String[] args) { List\u0026lt;Person\u0026gt; list = Person.getList(); Map\u0026lt;Integer, String\u0026gt; nameByAge = list.stream().collect(Collectors.groupingBy(Person::getAge, Collectors.mapping(Person::getName, Collectors.joining(\u0026#34;,\u0026#34;)))); nameByAge.forEach((k,v)-\u0026gt;System.out.println(\u0026#34;Age:\u0026#34;+k +\u0026#34; Persons: \u0026#34;+v)); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } public static List\u0026lt;Person\u0026gt; getList() { List\u0026lt;Person\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Person(\u0026#34;Ram\u0026#34;, 30)); list.add(new Person(\u0026#34;Shyam\u0026#34;, 20)); list.add(new Person(\u0026#34;Shiv\u0026#34;, 20)); list.add(new Person(\u0026#34;Mahesh\u0026#34;, 30)); return list; } } 输出结果如下 Age:20 Persons: Shyam,Shiv Age:30 Persons: Ram,Mahesh   ","description":"一、Java8 收集器 - java.util.stream.Collectors","id":0,"section":"posts","tags":["java8"],"title":"一、Java8 收集器 - java.util.stream.Collectors","uri":"http://www.wty.center/zh/posts/%E4%B8%80java8-%E6%94%B6%E9%9B%86%E5%99%A8-java.util.stream.collectors/"},{"content":"引言 本章节我们来详细讲讲 Java 8 流 ( stream ) 收集器 ( Collectors ) 中的 joining() 方法。该方法会返回一个 Collectors 实例，方便在流收集器上的链式操作。\nCollectors.joining() 方法以遭遇元素的顺序拼接元素。我们可以传递可选的拼接字符串、前缀和后缀\njoinning() 方法定义 假设我们的流中有四个元素[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;D\u0026rdquo;]，那么我们就可以按照以下方式来收集它们\njoining() joinning()无参数方法会返回一个 Collectors 实例，并且以空字符串 ( “” ) 来拼接收集到的所有元素\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;); String result= list.stream().collect(Collectors.joining()); System.out.println(result); } } 输出结果为 ABCD   joining(CharSequence delimiter) joining(CharSequence delimiter)接受一个参数字符串序列作为拼接符，并返回一个 Collectors 实例。假如我们传递的拼接符为 “-” 。那么输出结果为A-B-C-D\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;); String result= list.stream().collect(Collectors.joining(\u0026#34;-\u0026#34;)); System.out.println(result); } } 运行结果为 A-B-C-D   joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)方法接受一个字符串序列作为拼接符，并在拼接完成后添加传递的前缀和后缀。假如我们传递的分隔符为 \u0026ldquo;-\u0026quot;，前缀为 \u0026ldquo;[\u0026rdquo; ， 后缀为 \u0026ldquo;]\u0026rdquo; 。那么输出结果为[A-B-C-D]\n1 2 3 4 5 6 7 8 9 10 11 12  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;); String result= list.stream().collect(Collectors.joining(\u0026#34;-\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;)); System.out.println(result); } } 运行结果为 [A-B-C-D]   范例 范例 1 ： 如果流中的数据是字符串 下面的代码演示了如何使用 joinning() 的三种重载方法来拼接字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  package com.souyunku.tech.util.stream; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class JoiningExampleWithListOfString { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;Ram\u0026#34;,\u0026#34;Shyam\u0026#34;,\u0026#34;Shiv\u0026#34;,\u0026#34;Mahesh\u0026#34;); String result= list.stream().collect(Collectors.joining()); System.out.println(result); result= list.stream().collect(Collectors.joining(\u0026#34;,\u0026#34;)); System.out.println(result); result= list.stream().collect(Collectors.joining(\u0026#34;-\u0026#34;,\u0026#34;[\u0026#34;,\u0026#34;]\u0026#34;)); System.out.println(result); } } 运行结果为 RamShyamShivMahesh Ram,Shyam,Shiv,Mahesh [Ram-Shyam-Shiv-Mahesh]   范例 2: 如果流中的数据是对象 如果流中的数据是对象，下面的代码演示了如何拼接它们。\n首先，我们创建一个 Person 类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package com.souyunku.tech.util.stream; import java.util.ArrayList; import java.util.List; public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } public static List\u0026lt;Person\u0026gt; getList() { List\u0026lt;Person\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Person(\u0026#34;Ram\u0026#34;, 23)); list.add(new Person(\u0026#34;Shyam\u0026#34;, 20)); list.add(new Person(\u0026#34;Shiv\u0026#34;, 25)); list.add(new Person(\u0026#34;Mahesh\u0026#34;, 30)); return list; } }   然后创建一个 Person 对象流\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package com.souyunku.tech.util.stream; import java.util.List; import java.util.stream.Collectors; public class JoiningExampleWithListOfObject { public static void main(String[] args) { List\u0026lt;Person\u0026gt; list = Person.getList(); System.out.println(\u0026#34;--Join person name--\u0026#34;); String result= list.stream().map(p -\u0026gt; p.getName()).collect(Collectors.joining()); System.out.println(result); result= list.stream().map(p -\u0026gt; p.getName()).collect(Collectors.joining(\u0026#34;|\u0026#34;)); System.out.println(result); result= list.stream().map(p -\u0026gt; p.getName()).collect(Collectors.joining(\u0026#34;-\u0026#34;,\u0026#34;[\u0026#34;,\u0026#34;]\u0026#34;)); System.out.println(result); System.out.println(\u0026#34;--Join person age--\u0026#34;); result= list.stream().map(p -\u0026gt; String.valueOf(p.getAge())).collect(Collectors.joining()); System.out.println(result); result= list.stream().map(p -\u0026gt; String.valueOf(p.getAge())).collect(Collectors.joining(\u0026#34;|\u0026#34;)); System.out.println(result); result= list.stream().map(p -\u0026gt; String.valueOf(p.getAge())).collect(Collectors.joining(\u0026#34;-\u0026#34;,\u0026#34;[\u0026#34;,\u0026#34;]\u0026#34;)); System.out.println(result); System.out.println(\u0026#34;--Join person name-age--\u0026#34;); result= list.stream().map(p -\u0026gt; p.getName()+\u0026#34;-\u0026#34; + p.getAge()).collect(Collectors.joining(\u0026#34;|\u0026#34;)); System.out.println(result); result= list.stream().map(p -\u0026gt; p.getName()+\u0026#34;-\u0026#34; + p.getAge()).collect(Collectors.joining(\u0026#34;|\u0026#34;,\u0026#34;[\u0026#34;,\u0026#34;]\u0026#34;)); System.out.println(result); } } 运行结果为 --Join person name-- RamShyamShivMahesh Ram|Shyam|Shiv|Mahesh [Ram-Shyam-Shiv-Mahesh] --Join person age-- 23202530 23|20|25|30 [23-20-25-30] --Join person name-age-- Ram-23|Shyam-20|Shiv-25|Mahesh-30 [Ram-23|Shyam-20|Shiv-25|Mahesh-30]   ","description":"三、Java8 Collectors.joining() 详解","id":1,"section":"posts","tags":["java8"],"title":"三、Java8 Collectors.joining() 详解","uri":"http://www.wty.center/zh/posts/%E4%B8%89java8-collectors.joining-%E8%AF%A6%E8%A7%A3/"},{"content":"引言 本章节我们提供一些 Java 8 中的 IntStream、LongStream 和 DoubleStream 使用范例。IntStream、LongStream 和 DoubleStream 分别表示原始 int 流、 原始 long 流 和 原始 double 流。\n这三个原始流类提供了大量的方法用于操作流中的数据，同时提供了相应的静态方法来初始化它们自己。\n这三个原始流类都在 java.util.stream 命名空间下。\njava.util.stream.IntStream java.util.stream.IntStream 是一个原始整数值序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作，比如 max() 或 average()\n聚合方法    方法 说明     rangeClosed(a,b) 返回子序列 [a,b]，包含起始值，增长步值为 1   range(a,b) 返回子序列 [a,b)，左闭右开，意味着不包括 b   sum 计算所有元素的总和   sorted 排序元素    这些方法使用示例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  IntStreamDemo.java package com.souyunku.tech.util.stream; import java.util.stream.IntStream; public class IntStreamDemo { public static void main(String[] args) { System.out.println(\u0026#34;--Using IntStream.rangeClosed--\u0026#34;); IntStream.rangeClosed(13, 15).map(n-\u0026gt;n*n).forEach(s-\u0026gt;System.out.print(s +\u0026#34; \u0026#34;)); System.out.println(\u0026#34;\\n--Using IntStream.range--\u0026#34;); IntStream.range(13,15).map(n-\u0026gt;n*n).forEach(s-\u0026gt;System.out.print(s +\u0026#34; \u0026#34;)); System.out.println(\u0026#34;\\n--Sum of range 1 to 10--\u0026#34;); System.out.print(IntStream.rangeClosed(1,10).sum()); System.out.println(\u0026#34;\\n--Sorted number--\u0026#34;); IntStream.of(13,4,15,2,8).sorted().forEach(s-\u0026gt;System.out.print(s +\u0026#34; \u0026#34;)); } } 运行结果如下 --Using IntStream.rangeClosed-- 169 196 225 --Using IntStream.range-- 169 196 --Sum of range 1 to 10-- 55 --Sorted number-- 2 4 8 13 15   LongStream java.util.stream.LongStream是一个原始长整型值序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作。其实，它的使用方式和 IntStream 一样，因为提供的方法也一样，我们就不做展开了，直接看范例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package com.souyunku.tech.util.stream; import java.util.stream.LongStream; public class LongStreamDemo { public static void main(String[] args) { System.out.println(\u0026#34;--Using LongStream.rangeClosed--\u0026#34;); LongStream.rangeClosed(13, 15).map(n-\u0026gt;n*n).forEach(s-\u0026gt;System.out.print(s +\u0026#34; \u0026#34;)); System.out.println(\u0026#34;\\n--Using LongStream.range--\u0026#34;); LongStream.range(13,15).map(n-\u0026gt;n*n).forEach(s-\u0026gt;System.out.print(s +\u0026#34; \u0026#34;)); System.out.println(\u0026#34;\\n--Sum of range 1 to 10--\u0026#34;); System.out.print(LongStream.rangeClosed(1,10).sum()); System.out.println(\u0026#34;\\n--Sorted number--\u0026#34;); LongStream.of(13,4,15,2,8).sorted().forEach(s-\u0026gt;System.out.print(s +\u0026#34; \u0026#34;)); } } 输出结果如下 --Using LongStream.rangeClosed-- 169 196 225 --Using LongStream.range-- 169 196 --Sum of range 1 to 10-- 55 --Sorted number-- 2 4 8 13 15 DoubleStream   java.util.stream.LongStream 是一个原始双精度浮点型序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作。它的使用方式和 IntStream 一样，提供的方法也一样，除此之外，还额外提供了几个聚合方法\n   方法 说明     average 计算平均值   max 查找最大值    下面的代码是 DoubleStream 类的一些简单的使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package com.souyunku.tech.util.stream; import java.util.function.DoublePredicate; import java.util.stream.DoubleStream; public class DoubleStreamDemo { public static void main(String[] args) { System.out.println(\u0026#34;--Using DoubleStream.of--\u0026#34;); DoubleStream.of(5.33,2.34,5.32,2.31,3.51).map(d-\u0026gt;d*1.5).forEach(s-\u0026gt;System.out.print(s +\u0026#34; \u0026#34;)); System.out.println(\u0026#34;\\n--Using DoubleStream.average--\u0026#34;); double val = DoubleStream.of(12.1,11.2,13.3).average().getAsDouble(); System.out.println(val); System.out.println(\u0026#34;--Using DoubleStream.max--\u0026#34;); val = DoubleStream.of(12.1,11.2,13.3).max().getAsDouble(); System.out.println(val); System.out.println(\u0026#34;--Using DoubleStream.filter--\u0026#34;); DoublePredicate range = d -\u0026gt; d \u0026gt; 12.11 \u0026amp;\u0026amp; d \u0026lt; 12.99; DoubleStream.of(12.1,11.2,12.3).filter(range).forEach(d-\u0026gt;System.out.print(d)); } } 输出结果如下 --Using DoubleStream.of-- 7、995 3.51 7.98 3.465 5.265 --Using DoubleStream.average-- 12、200000000000001 --Using DoubleStream.max-- 13、3 --Using DoubleStream.filter-- 12、3   ","description":"二、Java8 IntStream,LongStream,DoubleStream","id":2,"section":"posts","tags":["java8"],"title":"二、Java8 IntStream,LongStream,DoubleStream","uri":"http://www.wty.center/zh/posts/%E4%BA%8Cjava8-intstreamlongstreamdoublestream/"},{"content":"下载地址：https://nodejs.org/en/\n  到nodejs目录下创建两个空文件夹，node_cahe和node_global  然后通过命令添加配置\nnpm config set prefix \u0026quot;E:/nodejs-16.3.1/node_global\u0026quot;\rnpm config set cache \u0026quot;E:/nodejs-16.3.1/node_cache\u0026quot;\r  接下来配置系统环境变量，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”\n进入环境变量对话框，在【系统变量】下新建【NODE_PATH】，输入【D:/Develop/nodejs/node_global/node_modules】，将【用户变量】下的【Path】修改为【D:/Develop/nodejs/node_global】\n  测试\nnpm version\r  ","description":"NodeJs环境变量的配置","id":3,"section":"posts","tags":["VUE","nodeJs"],"title":"NodeJs环境变量的配置","uri":"http://www.wty.center/zh/posts/nodejs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"content":"本文主要介绍MybatisPlus中的组件Dynamic实现动态数据源切换；\n  Pom配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dynamic-datasource-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Mysql驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Druid连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Mybatis Plus --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;     Yaml文件配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  server:port:8080spring:application:name:demo_oneautoconfigure:#自动化配置 例外处理exclude:com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfiguredatasource:type:com.alibaba.druid.pool.DruidDataSourcedynamic:primary:mysql#默认数据源datasource:mysql1:url:jdbc:mysql://mysqlIP:3306/test?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT%2B8username:rootpassword:123456driver-class-name:com.mysql.cj.jdbc.Drivermysql2:url:jdbc:mysql://mysqlIP:3306/test?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;useSSL=false\u0026amp;serverTimezone=GMT%2B8username:rootpassword:123456driver-class-name:com.mysql.cj.jdbc.Driver#\t如果是oracel 也是一样的# oracle:# url: jdbc:oracle:thin:@127.0.0.1:1521:xe# username: system# password: 123123# driver-class-name: oracle.jdbc.OracleDriverdruid:max-active:50max-wait:10000min-idle:3initial-size:5mybatis-plus:# mapper-locations:复杂的操作可能需要自己写SQL，SQL可以写到xml文件中，这里指定和Dao对应的xml文件，此时我们需要在resources中创建一个mapper目录mapper-locations:mapper/*.xml# type-aliases-package:指定JavaBean的别名包，和MyBatis用法一样type-aliases-package:com.*.entityconfiguration:# map-underscore-to-camel-case:开启驼峰功能，数据库表列名如果有_，可以自动按驼峰命名规则转换map-underscore-to-camel-case:true# log-impl:日志开启，方便测试log-impl:org.apache.ibatis.logging.stdout.StdOutImpl    动态数据切换\n  直接使用注解指定数据源，具体使用例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  package com.wty.demo_one.mapper; import com.baomidou.dynamic.datasource.annotation.DS; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.wty.demo_one.entity.User; import org.apache.ibatis.annotations.Mapper; @Mapper @DS(\u0026#34;mysql2\u0026#34;)//可以使用在类上 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { @DS(\u0026#34;mysql1\u0026#34;)//也可以使用在方法上  User selectOne(Long userId); }       ","description":"SpringBoot+MyBatisPlus 实现多数据源动态切换","id":4,"section":"posts","tags":["springBoot","MyBatisPlus"],"title":"SpringBoot+MyBatisPlus 实现多数据源动态切换","uri":"http://www.wty.center/zh/posts/springboot+mybatisplus-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2/"},{"content":"  拉取git项目 git地址为\n1  https://github.com/PanJiaChen/vue-element-admin.git     安装依赖 1  npm install   等待结束就完事了！！\n  目录结构   配置信息 vue.config.js 这里面配置了项目的基本信息： 所使用的环境、端口号、对外路径、输入文件路径等信息 , 可以看到我们使用的dev开发环境，下面将查看开发环境的配置\n.env.development 在这里会标注我们后台的路径， 此时因为使用的是mock数据， 所有只是提供了一下路径而已。以及标注当前文件的类型\nENV = ‘development’ 此时便引入了与后端数据交互， 与后端的交互接口都在 api的文件家里面。\n  文件分析 API文件夹 使用user.js举例 , 可以看到这个文件会向后端发送http请求， 但是它使用的是 /utils/request 里面的内容\n先说明此文件的作用， 在这个开源框架中与后端交互使用的是 axios 组件。指定请求的路径、类型、请求参数、请求体参数， 就可以执行异步亲求了。下一步介绍 /utils/request。\n/utils/request 首先创建一个axios的实例， 对于这个实例需要设定的有： 基本的URL、以及请求超时的。\n第二步是添加拦截器， axios每次请求都会经过这个拦截器。 store.getters.token 首先从全局状态管理那里判断 token , 有的话就可以请求， 否则就抛出异常。并且可以清楚的看到如果有 token的话， 我们在请求的时候会得到当前的token 并且直接添加到请求头中， 以便后端得到当前登录的信息。\n下面是对返回结果的拦截， 在这里会判断返回结果中的状态码， 根据状态码来判断这次请求的状态如何。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  // response interceptor service.interceptors.response.use( /** * If you want to get http information such as headers or status * Please return response =\u0026gt; response */ /** * Determine the request status by custom code * Here is just an example * You can also judge the status by HTTP Status Code */ response =\u0026gt; { const res = response.data // if the custom code is not 20000, it is judged as an error.  if (res.code !== 20000) { Message({ message: res.message || \u0026#39;Error\u0026#39;, type: \u0026#39;error\u0026#39;, duration: 5 * 1000 }) // 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired;  if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // to re-login  MessageBox.confirm(\u0026#39;You have been logged out, you can cancel to stay on this page, or log in again\u0026#39;, \u0026#39;Confirm logout\u0026#39;, { confirmButtonText: \u0026#39;Re-Login\u0026#39;, cancelButtonText: \u0026#39;Cancel\u0026#39;, type: \u0026#39;warning\u0026#39; }).then(() =\u0026gt; { store.dispatch(\u0026#39;user/resetToken\u0026#39;).then(() =\u0026gt; { location.reload() }) }) } return Promise.reject(new Error(res.message || \u0026#39;Error\u0026#39;)) } else { return res } }, error =\u0026gt; { console.log(\u0026#39;err\u0026#39; + error) // for debug  Message({ message: error.message, type: \u0026#39;error\u0026#39;, duration: 5 * 1000 }) return Promise.reject(error) } )   最后将 axios的实例导出 export default service， 在这里我们看到了 store.getters.token 以及文件最上面的导入\n1 2  import store from \u0026#39;@ /store\u0026#39; store.getters.token // 下一步查看 /store 这个文件夹   /store 简单介绍此文件中几个重要的知识点\nState提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储\nMutation用于修改变更$store中的数据\n在mutations中不能编写异步的代码，会导致vue调试器的显示出错。在vuex中我们可以使用Action来执行异步操作。\nGetter用于对Store中的数据进行加工处理形成新的数据\n它只会包装Store中保存的数据，并不会修改Store中保存的数据，当Store中的数据发生变化时，Getter生成的内容也会随之变化\n1  token: state =\u0026gt; state.user.token,   在 gettes 文件中我们看到了 token 这个标识， 其中 gettes 文件就是为了我们方便从全局状态管理中获取数据的工具， 在这里可以得到当前的 token 。\n此文件主要是使用了 vuex , 而 vuex 是 vue中的全局的状态管理， 方便我们进行组件之间的数据传递。基本使用如下\n1 2 3 4 5 6 7  this.$store.state.count // 得到store中值  // 调用Acton中的异步方法 user.js 中的login 方法 ， 这个是 /veew/login 文件中的代码 this.$store.dispatch(\u0026#39;user/login\u0026#39;, this.loginForm).then(() =\u0026gt; { this.$router.push({path: this.redirect || \u0026#39;/\u0026#39;}) this.loading = false })   token 相关的 1 2 3 4 5 6  RESET_STATE: (state) =\u0026gt; { Object.assign(state, getDefaultState()) }, SET_TOKEN: (state, token) =\u0026gt; { state.token = token },   登录相关的 举例说明 login 方法， 首先 传入 {commit} 以及在方法中 commit(‘SET_TOKEN’, data.token) 这两个的作用是执行 action 中异步方法的简写， 组用就是设置 token 的值， 我们知道修改 store中的数据需要使用 Mutation 就是会调用上面的 SET_TOKEN 把 后端返回的token 保存到vuex中， 并且使用 setToken(data.token) 方法把 token写入到 cookie中 以便我们每次请求都可以带上这个 cookie , 并且能够解析出当前登录的用户 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // user login  login({commit}, userInfo) { console.log(\u0026#39;login\u0026#39;) const {username, password} = userInfo console.log(\u0026#34;user info -\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34; + username + \u0026#34;=\u0026gt;\u0026gt;\u0026gt;\u0026#34; + password) return new Promise((resolve, reject) =\u0026gt; { login({username: username.trim(), password: password}).then(response =\u0026gt; { const {data} = response commit(\u0026#39;SET_TOKEN\u0026#39;, data.token) console.log(data.token) setToken(data.token) resolve() }).catch(error =\u0026gt; { reject(error) }) }) },   在这个文件中我们还可以观察到最上面存在组件的导入， 这就和之前的说明相匹配。\n1 2 3 4  import {login, logout, getInfo} from \u0026#39;@/api/user\u0026#39; import {getToken, setToken, removeToken} from \u0026#39;@/utils/auth\u0026#39; import {resetRouter} from \u0026#39;@/router\u0026#39;   main.js 这个是项目的入口文件， 在这个入口文件中， 我们看到当前是使用mock数据， 并且全局挂在 element - ui 以及在vue的实例中挂载了 路由、store (vuex) ， 那下一步开始讲解路由\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  if (process.env.NODE_ENV === \u0026#39;production\u0026#39;) { const { mockXHR } = require(\u0026#39;../mock\u0026#39;) mockXHR() } // set ElementUI lang to EN // Vue.use(ElementUI, { locale }) // 如果想要中文版 element-ui，按如下方式声明 Vue.use(ElementUI) Vue.config.productionTip = false new Vue({ el: \u0026#39;#app\u0026#39;, router, store, render: h =\u0026gt; h(App) })   / router 使用vue router的第一步是需要一个路由表、以及把路由表加载到路由实例中， 最后把路由实例导出。下面就是定义的路由表， 对于路由表 中包括\npath : 访问的路径\ncomponent ： 此路由对于的组件\nhidden ： 是否在界面显示此路由\nmeta ： 设置路由的属性， 图标之类的\nname : 路由名字\nchildren ： 该路由下的子路由， 效果就是二级菜单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  export const constantRoutes = [ { path: \u0026#39;/login\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/login/index\u0026#39;), hidden: true, children: [ { path: \u0026#39;https://panjiachen.github.io/vue-element-admin-site/#/\u0026#39;, meta: {title: \u0026#39;External Link\u0026#39;, icon: \u0026#39;link\u0026#39;} } }, { path: \u0026#39;/404\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/404\u0026#39;), hidden: true },   下面就是新建路由实例， 以及添加路由表， 导出路由。 上面介绍到了组件， 下一步解释路由对应的组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const createRouter = () =\u0026gt; new Router({ // mode: \u0026#39;history\u0026#39;, // require service support  scrollBehavior: () =\u0026gt; ({y: 0}), routes: constantRoutes }) const router = createRouter() // Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465 export function resetRouter() { const newRouter = createRouter() router.matcher = newRouter.matcher // reset router } export default router   /view/login/login.vue 组件的概念比较广泛，可以暂时理解为一个界面， 下面是登录的界面， name: ‘Login’, 定义的组件名称。 当在路由表中配置了此路由的信息后，就可以在使用中根据对应的path 来访问此路由。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;login-container\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import {validUsername} from \u0026#39;@/utils/validate\u0026#39; export default { name: \u0026#39;Login\u0026#39;, data() { }, watch: { }, methods: { } } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34;\u0026gt; \u0026lt;/style\u0026gt;   permission.js 此文件是用来配合路由使用的， 对于vue router 而言它还附带了一些其他的信息， 比如路由守卫， 在路由守卫中我们可以在路由跳转之前来做一些事情的。\n对于此项目来讲；\n1、首先判断是否有token\n2、没有token ， 如果在白名单里面， 就直接放行， 否则就直接强制跳转登录。\n3、有token , 如果是 /login 就就直接到 根目录下\n4、不是 /login 就去 store 里面找 当前用户的信息， 然后在放行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  const whiteList = [\u0026#39;/login\u0026#39;] // no redirect whitelist  router.beforeEach(async(to, from, next) =\u0026gt; { // start progress bar  NProgress.start() // set page title  document.title = getPageTitle(to.meta.title) // determine whether the user has logged in  //console.log(getToken())  const hasToken = getToken() if (hasToken) { if (to.path === \u0026#39;/login\u0026#39;) { // if is logged in, redirect to the home page  next({ path: \u0026#39;/\u0026#39; }) NProgress.done() } else { const hasGetUserInfo = store.getters.name if (hasGetUserInfo) { next() } else { try { // get user info  await store.dispatch(\u0026#39;user/getInfo\u0026#39;) next() } catch (error) { // remove token and go to login page to re-login  await store.dispatch(\u0026#39;user/resetToken\u0026#39;) Message.error(error || \u0026#39;Has Error\u0026#39;) next(`/login?redirect=${to.path}`) NProgress.done() } } } } else { /* has no token*/ if (whiteList.indexOf(to.path) !== -1) { // in the free login whitelist, go directly  next() } else { // other pages that do not have permission to access are redirected to the login page.  next(`/login?redirect=${to.path}`) NProgress.done() } } })   参考博文：https://blog.csdn.net/qq_41291945/article/details/107748231\n  ","description":"VUE模板的使用","id":5,"section":"posts","tags":["VUE","vue-admin-template"],"title":"VUE模板的使用(一)","uri":"http://www.wty.center/zh/posts/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%80/"},{"content":"Docker容器信息 ##查看docker容器版本\rdocker version\r##查看docker容器信息\rdocker info\r##查看docker容器帮助\rdocker --help\rdocker安装启动 安装比较简单，这种安装的Docker不是最新版本，不过对于学习够用了，依次执行下面命令进行安装。\n$ sudo apt install docker.io\r$ sudo systemctl start docker\r$ sudo systemctl enable docker\r镜像操作 镜像查看 提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。\n##列出本地images\rdocker images\r##含中间映像层\rdocker images -a\r##只显示镜像ID\rdocker images -q\r##含中间映像层\rdocker images -qa ##显示镜像摘要信息(DIGEST列)\rdocker images --digests\r##显示镜像完整信息\rdocker images --no-trunc\r##显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc 显示完整的提交记录；-q 仅列出提交记录ID\rdocker history -H redis\r镜像搜索 ##搜索仓库MySQL镜像\rdocker search mysql\r## --filter=stars=600：只显示 starts\u0026gt;=600 的镜像\rdocker search --filter=stars=600 mysql\r## --no-trunc 显示镜像完整 DESCRIPTION 描述\rdocker search --no-trunc mysql\r## --automated ：只列出 AUTOMATED=OK 的镜像\rdocker search --automated mysql\r镜像下载 ##下载Redis官方最新镜像，相当于：docker pull redis:latest\rdocker pull redis\r##下载仓库所有Redis镜像\rdocker pull -a redis\r##下载私人仓库镜像\rdocker pull bitnami/redis\r镜像删除 ##单个镜像删除，相当于：docker rmi redis:latest\rdocker rmi redis\r##强制删除(针对基于镜像有运行的容器进程)\rdocker rmi -f redis\r##多个镜像删除，不同镜像间以空格间隔\rdocker rmi -f redis tomcat nginx\r##删除本地全部镜像\rdocker rmi -f $(docker images -q)\r镜像构建\n##（1）编写dockerfile\rcd /docker/dockerfile\rvim mycentos\r##（2）构建docker镜像\rdocker build -f /docker/dockerfile/mycentos -t mycentos:1.1\r容器操作 提示：对于容器的操作可使用CONTAINER ID 或 NAMES。\n容器启动 ##新建并启动容器，参数：-i 以交互模式运行容器；-t 为容器重新分配一个伪输入终端；--name 为容器指定一个名称\rdocker run -i -t --name mycentos\r##后台启动容器，参数：-d 已守护方式启动容器\rdocker run -d mycentos\r注意：此时使用\u0026quot;docker ps -a\u0026quot;会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。\n##启动一个或多个已经被停止的容器\rdocker start redis\r##重启容器\rdocker restart redis\r容器进程 ##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]\r##列出redis容器中运行进程\rdocker top redis\r##查看所有运行容器的进程信息\rfor i in `docker ps |grep Up|awk '{print $1}'`;do echo / \u0026amp;\u0026amp;docker top $i; done\r容器日志 ##查看redis容器日志，默认参数\rdocker logs rabbitmq\r##查看redis容器日志，参数：-f 跟踪日志输出；-t 显示时间戳；--tail 仅列出最新N条容器日志；\rdocker logs -f -t --tail=20 redis\r##查看容器redis从2019年05月21日后的最新10条日志。\rdocker logs --since=\u0026quot;2019-05-21\u0026quot; --tail=10 redis\r容器的进入与退出 ##使用run方式在创建时进入\rdocker run -it centos /bin/bash\r##关闭容器并退出\rexit\r##仅退出容器，不关闭\r快捷键：Ctrl + P + Q\r##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false 确保CTRL-D或CTRL-C不会关闭容器\rdocker attach --sig-proxy=false centos ##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i 即使没有附加也保持STDIN 打开；-t 分配一个伪终端\rdocker exec -i -t centos /bin/bash\r##以交互模式在容器中执行命令，结果返回到当前终端屏幕\rdocker exec -i -t centos ls -l /tmp\r##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端\rdocker exec -d centos touch cache.txt 查看容器 ##查看正在运行的容器\rdocker ps\r##查看正在运行的容器的ID\rdocker ps -q\r##查看正在运行+历史运行过的容器\rdocker ps -a\r##显示运行容器总文件大小\rdocker ps -s\r##显示最近创建容器\rdocker ps -l\r##显示最近创建的3个容器\rdocker ps -n 3\r##不截断输出\rdocker ps --no-trunc ##获取镜像redis的元信息\rdocker inspect redis\r##获取正在运行的容器redis的 IP\rdocker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' redis\r容器的停止与删除 ##停止一个运行中的容器\rdocker stop redis\r##杀掉一个运行中的容器\rdocker kill redis\r##删除一个已停止的容器\rdocker rm redis\r##删除一个运行中的容器\rdocker rm -f redis\r##删除多个容器\rdocker rm -f $(docker ps -a -q)\rdocker ps -a -q | xargs docker rm\r## -l 移除容器间的网络连接，连接名为 db\rdocker rm -l db ## -v 删除容器，并删除容器挂载的数据卷\rdocker rm -v redis\r生成镜像 ##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停\rdocker commit -a=\u0026quot;DeepInThought\u0026quot; -m=\u0026quot;my redis\u0026quot; [redis容器ID] myredis:v1.1\r容器与主机之间的数据拷贝 ##将rabbitmq容器中的文件copy至本地路径\rdocker cp rabbitmq:/[container_path] [local_path]\r##将主机文件copy至rabbitmq容器\rdocker cp [local_path] rabbitmq:/[container_path]/\r##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）\rdocker cp [local_path] rabbitmq:/[container_path]\r","description":"Docker常用命令","id":6,"section":"posts","tags":["docker"],"title":"Docker常用命令","uri":"http://www.wty.center/zh/posts/docker_command/"},{"content":"sublime设置\u0026quot;update_check\u0026quot;: false,没有效果 Preferences-\u0026gt;Settings-User中设置\u0026quot;update_check\u0026quot;:false,（注意是英文符号，逗号结尾）\n可是没有什么效果，重启还是还是弹出来自动更新的提示，直到注册了软件之后：\nhelp－Enter License输入\n—– BEGIN LICENSE —– TwitterInc 200 User License EA7E-890007 1D77F72E 390CDD93 4DCBA022 FAF60790 61AA12C0 A37081C5 D0316412 4584D136 94D7F7D4 95BC8C1C 527DA828 560BB037 D1EDDD8C AE7B379F 50C9D69D B35179EF 2FE898C4 8E4277A8 555CE714 E1FB0E43 D5D52613 C3D12E98 BC49967F 7652EED2 9D2D2E61 67610860 6D338B72 5CF95C69 E36B85CC 84991F19 7575D828 470A92AB —— END LICENSE —— 如果提示已过期，上网重新找注册码！！\n","description":"sublime小技巧","id":7,"section":"posts","tags":["工具"],"title":"sublime设置取消更新无效","uri":"http://www.wty.center/zh/posts/sublime_setting/"},{"content":"前言 搭建梯子主要分为以下几个步骤：\n 租借vps; 安装ssh远程登陆客户端； 通过脚本安装Shadowsocks; 安装SSR客户端，科学上网;  租借vps 上图所展示的就是国外常用的vps服务商，以前用过vultr和hostinger，体验并不算特别好，端口经常被封，网速还不怎么快。我现在用的是国内腾讯云的香港服务器。vultr里面买一个最低配置的也是一个月5美刀，腾讯云的话一年三百多，算起来价格差不多。所以还是强烈推荐国内用户使用腾讯云的服务器把！！\n安装ssh远程登陆客户端 百度搜索finalShell\n傻瓜式下一步安装；\n连接到自己的服务器\n成功登录，出现[root@xxxx ~]#后，全部复制以下代码粘贴回车（一键安装脚本）\n通过脚本安装Shadowsockss 输入一下命令回车执行\n1  wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh   然后添加文件权限\n1  chmod +x shadowsocks.sh   接着执行脚本，设置ss的密码端口和加密方式。\n1  ./shadowsocks.sh 2\u0026gt;\u0026amp;1 | tee shadowsocks.log   然后按照要求输入密码、端口、加密方式\n按任意键开始…或按Ctrl+C取消\n输入完后，脚本执行自动安装，此时需要等待5-15几分钟安装完成。\n当出现上图信息时，说明SS已经搭建成功。\n如果需要修改配置信息输入以下命令\n1  vim /etc/shadowsocks.json   这个就是配置文件，按a进行输入，:wq 进行保存；\n保存成功后执行一下命令进行重启\n常用：\n启动\n1  ssserver -c /etc/shadowsocks.json -d start   停止\n1  ssserver -c /etc/shadowsocks.json -d stop   重启\n1  ssserver -c /etc/shadowsocks.json -d reload   安装SSR客户端，科学上网 客户端下载好直接双击就可以使用了，不需要安装；\nWindows 版本SSR客户端\nhttps://www.magento2u.com/wp-content/uploads/ShadowsocksR-4.7.0-win.zip\nmacOS 版本SSR客户端\nhttps://www.magento2u.com/wp-content/uploads/shadowsocksr-android-3.5.4.zip\nAndroid 版本SSR客户端\nhttps://www.magento2u.com/wp-content/uploads/ShadowsocksX-NG-R8.zip\n打开以后，在桌面右下角任务栏出现，点右键，点从粘贴板导入，然后就是见证奇迹的时刻，我们成功了。安卓端的ssr工具也很多，自行下载安装包安装就好，用法都差不多，ios下，国内市场的ssr客户端都下架了，需要去美区App Store下载，美区账号在淘宝买就好，一般一两块钱一个，ios端推荐Shadowrocket，不过要花钱买，几块钱，用我们之前注册的PayPal就好，也有个免费的Patatso Lite。用法都差不多，从剪贴板导入ssr地址就好。\n结语 相对于ssr我还是比较倾向于用ss来作为服务端，以前用ssr的时候经常段都被封，后面换了ss端口很少被封了。客户端使用ssr是因为体验感比ss强多了。。\n ","description":"科学上网傻瓜式教程","id":8,"section":"posts","tags":["科学上网","工具"],"title":"傻瓜式搭建科学上网梯子（VPN）","uri":"http://www.wty.center/zh/posts/ssr_vpn/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":9,"section":"gallery","tags":null,"title":"图片","uri":"http://www.wty.center/zh/gallery/photo/"},{"content":"写字楼里写字间，写字间里程序员；程序人员写程序，又拿程序换酒钱。\n酒醒只在网上坐，酒醉还来网下眠；酒醉酒醒日复日，网上网下年复年。\n……\n宁愿老死程序间，只要老板多发钱；小车大房不去想，撰个2 k好过年。\n若要见识新世面，公务员比程序员；一个在天一在地，而且还比我们闲。\n别人看我穿白领，我看别人穿名牌；天生我才写程序，臀大近视肩周炎。\n年复一年春光度,度得他人做老板;老板扣我薄酒钱,没有酒钱怎过年.\n春光逝去皱纹起,作起程序也委靡;来到水源把水灌,打死不做程序员.\n别人笑我忒疯癫，我笑他人命太贱；状元三百六十行，偏偏来做程序员！！\n但愿老死电脑间，不愿鞠躬老板前；奔驰宝马贵者趣，公交自行程序员。\n若将程员比妓女，一在平地一在天；若将程员比车马，他得驱驰我无闲。\n别人笑我忒疯癫，我笑自己命太贱；不见满街漂亮妹，哪个归得程序员。\n不想只挣打工钱，那个老板愿发钱；小车大房咱要想，任我享用多悠闲。\n比尔能搞个微软，我咋不能捞点钱；一个在天一在地，定有一日乾坤翻。\n我在天来他在地，纵横天下山水间；傲视武林豪杰墓，一樽还垒风月山。\n电脑面前眼发直，眼镜下面泪茫茫；做梦发财好几亿，从此不用手指忙。\n哪知梦醒手空空，老板看到把我训；待到老时眼发花，走路不知哪是家。\n各位在此穷抱怨，可知小弟更可怜；俺学编程两年半，至今没赚一分钱。\n听说三十是末日，二十三岁在眼前；发誓立志傍微软，渺渺前程对谁言？\n小农村里小民房，小民房里小民工；小民工人写程序，又拿代码讨赏钱。\n钱空只在代码中，钱醉仍在代码间；有钱无钱日复日，码上码下年复年。\n但愿老死代码间，不愿鞠躬奥迪前，奥迪奔驰贵者趣，程序代码贫者缘。\n若将贫贱比贫者，一在平地一在天；若将贫贱比车马，他得驱驰我得闲。\n别人笑我忒疯癫，我笑他人看不穿；不见盖茨两手间，财权富贵世人鉴。\n","description":"Hugo, the world’s fastest framework for building websites","id":10,"section":"","tags":null,"title":"About","uri":"http://www.wty.center/zh/about/"},{"content":"后端接口   配置跨域\n已拦截跨源请求：同源策略禁止读取位于 http://127.0.0.1:8080/user/login 的远程资源。（原因：CORS 请求未能成功） 需要添加如下配置解决跨域问题！\n 不同主机 不同端口 不同协议  都会产生跨域问题！\n1 2 3 4 5 6 7 8 9 10  @Configuration public class CorsConfiguration implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) .allowedMethods(\u0026#34;*\u0026#34;) .allowedOrigins(\u0026#34;*\u0026#34;) .allowedHeaders(\u0026#34;*\u0026#34;); } }     登录接口\n此处需要返回的是用户信息以及登录后的token ， 后端配置：\n  port : 8001\n  路径：/api\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  @GetMapping(\u0026#34;/user/info\u0026#34;) public ResultVO\u0026lt;HashMap\u0026gt; getInfo(String token) { log.info(\u0026#34;get user info : \u0026#34; + token); String username = jwtConfig.getUsernameFromToken(token); log.info(\u0026#34;user name : \u0026#34; + username); HashMap\u0026lt;Object, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;roles\u0026#34;, \u0026#34;admin\u0026#34;); map.put(\u0026#34;introduction\u0026#34;, \u0026#34;I am a superadministrator\u0026#34;); map.put(\u0026#34;avatar\u0026#34;, \u0026#34;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026#34;); map.put(\u0026#34;name\u0026#34;, \u0026#34;Super Admin\u0026#34;); return ResultVOUtil.successWith(map); } @PostMapping(\u0026#34;/user/login\u0026#34;) public ResultVO\u0026lt;String\u0026gt; login(@RequestBody User user) { String token = jwtConfig.createToken(user.getUsername()); log.info(\u0026#34;user \u0026#34; + user.toString()); log.info(\u0026#34;token \u0026#34; + token); return ResultVOUtil.successWith(token); }     前端修改 此时我们只需要把前端的 访问 url 以及端口 请求的路径做出对应的修改即可。\n.env.development 1 2 3 4 5  # just a flag ENV = \u0026#39;development\u0026#39; # base api # VUE_APP_BASE_API = \u0026#39;/dev-api\u0026#39; VUE_APP_BASE_API = \u0026#39;http://127.0.0.1:8001/api/\u0026#39;   vue.config.js 1 2 3 4 5 6 7 8 9  devServer: { port: port, open: true, overlay: { warnings: false, errors: true }/*, before: require(\u0026#39;./mock/mock-server.js\u0026#39;)*/ },   api/user.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import request from \u0026#39;@/utils/request\u0026#39; export function login(data) { return request({ url: \u0026#39;/user/login\u0026#39;, method: \u0026#39;post\u0026#39;, data }) } export function getInfo(token) { return request({ url: \u0026#39;/user/info\u0026#39;, method: \u0026#39;get\u0026#39;, params: { token } }) }     ","description":"","id":11,"section":"posts","tags":null,"title":"","uri":"http://www.wty.center/zh/posts/vue%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/"}]